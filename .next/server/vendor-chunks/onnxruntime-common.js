/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-common";
exports.ids = ["vendor-chunks/onnxruntime-common"];
exports.modules = {

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/ort-common.node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/ort-common.node.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * ONNX Runtime Common v1.14.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n(()=>{\"use strict\";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};e.r(t),e.d(t,{InferenceSession:()=>c,Tensor:()=>g,env:()=>i,registerBackend:()=>o});const r={},n=[],o=(e,t,o)=>{if(!t||\"function\"!=typeof t.init||\"function\"!=typeof t.createSessionHandler)throw new TypeError(\"not a valid backend\");{const i=r[e];if(void 0===i)r[e]={backend:t,priority:o};else{if(i.priority>o)return;if(i.priority===o&&i.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${o}`)}if(o>=0){const t=n.indexOf(e);-1!==t&&n.splice(t,1);for(let t=0;t<n.length;t++)if(r[n[t]].priority<=o)return void n.splice(t,0,e);n.push(e)}}},i=new class{constructor(){this.wasm={},this.webgl={},this.logLevelInternal=\"warning\"}set logLevel(e){if(void 0!==e){if(\"string\"!=typeof e||-1===[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},a=\"undefined\"!=typeof BigInt64Array&&\"function\"==typeof BigInt64Array.from,s=\"undefined\"!=typeof BigUint64Array&&\"function\"==typeof BigUint64Array.from,d=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array]]),f=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]);a&&(d.set(\"int64\",BigInt64Array),f.set(BigInt64Array,\"int64\")),s&&(d.set(\"uint64\",BigUint64Array),f.set(BigUint64Array,\"uint64\"));class h{constructor(e,t,r){let n,o,i;if(\"string\"==typeof e)if(n=e,i=r,\"string\"===e){if(!Array.isArray(t))throw new TypeError(\"A string tensor's data must be a string array.\");o=t}else{const r=d.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))o=r.from(t);else{if(!(t instanceof r))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);o=t}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");const t=typeof e[0];if(\"string\"===t)n=\"string\",o=e;else{if(\"boolean\"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n=\"bool\",o=Uint8Array.from(e)}}else{const t=f.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,o=e}if(void 0===i)i=[o.length];else if(!Array.isArray(i))throw new TypeError(\"A tensor's dims must be a number array\");const a=(e=>{let t=1;for(let r=0;r<e.length;r++){const n=e[r];if(\"number\"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t})(i);if(a!==o.length)throw new Error(`Tensor's size(${a}) does not match data length(${o.length}).`);this.dims=i,this.type=n,this.data=o,this.size=a}static bufferToTensor(e,t){if(void 0===e)throw new Error(\"Image buffer must be defined\");if(void 0===t.height||void 0===t.width)throw new Error(\"Image height and width must be defined\");const{height:r,width:n}=t,o=t.norm;let i,a;i=void 0===o||void 0===o.mean?255:o.mean,a=void 0===o||void 0===o.bias?0:o.bias;const s=void 0!==t.bitmapFormat?t.bitmapFormat:\"RGBA\",d=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:\"RGB\",f=r*n,g=\"RGBA\"===d?new Float32Array(4*f):new Float32Array(3*f);let m=4,c=0,l=1,w=2,u=3,p=0,y=f,b=2*f,v=-1;\"RGB\"===s&&(m=3,c=0,l=1,w=2,u=-1),\"RGBA\"===d?v=3*f:\"RBG\"===d?(p=0,b=f,y=2*f):\"BGR\"===d&&(b=0,y=f,p=2*f);for(let t=0;t<f;t++,c+=m,w+=m,l+=m,u+=m)g[p++]=(e[c]+a)/i,g[y++]=(e[l]+a)/i,g[b++]=(e[w]+a)/i,-1!==v&&-1!==u&&(g[v++]=(e[u]+a)/i);return new h(\"float32\",g,\"RGBA\"===d?[1,4,r,n]:[1,3,r,n])}static async fromImage(e,t){const r=\"undefined\"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,n=\"undefined\"!=typeof ImageData&&e instanceof ImageData,o=\"undefined\"!=typeof ImageBitmap&&e instanceof ImageBitmap,i=\"undefined\"!=typeof String&&(e instanceof String||\"string\"==typeof e);let a,s={};if(r){const r=document.createElement(\"canvas\"),n=r.getContext(\"2d\");if(null==n)throw new Error(\"Can not access image data\");{let o=e.naturalHeight,i=e.naturalWidth;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(o=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");if(s.tensorFormat=\"RGBA\",void 0!==t.height&&t.height!==o)throw new Error(\"Image input config height doesn't match HTMLImageElement height\");if(s.height=o,void 0!==t.width&&t.width!==i)throw new Error(\"Image input config width doesn't match HTMLImageElement width\");s.width=i}else s.tensorFormat=\"RGBA\",s.height=o,s.width=i;r.width=i,r.height=o,n.drawImage(e,0,0,i,o),a=n.getImageData(0,0,i,o).data}}else{if(!n){if(o){if(void 0===t)throw new Error(\"Please provide image config with format for Imagebitmap\");if(void 0!==t.bitmapFormat)throw new Error(\"Image input config format must be defined for ImageBitmap\");const r=document.createElement(\"canvas\").getContext(\"2d\");if(null!=r){const n=e.height,o=e.width;if(r.drawImage(e,0,0,o,n),a=r.getImageData(0,0,o,n).data,void 0!==t){if(void 0!==t.height&&t.height!==n)throw new Error(\"Image input config height doesn't match ImageBitmap height\");if(s.height=n,void 0!==t.width&&t.width!==o)throw new Error(\"Image input config width doesn't match ImageBitmap width\");s.width=o}else s.height=n,s.width=o;return h.bufferToTensor(a,s)}throw new Error(\"Can not access image data\")}if(i)return new Promise(((r,n)=>{const o=document.createElement(\"canvas\"),i=o.getContext(\"2d\");if(!e||!i)return n();const a=new Image;a.crossOrigin=\"Anonymous\",a.src=e,a.onload=()=>{o.width=a.width,o.height=a.height,i.drawImage(a,0,0,o.width,o.height);const e=i.getImageData(0,0,o.width,o.height);if(void 0!==t){if(void 0!==t.height&&t.height!==o.height)throw new Error(\"Image input config height doesn't match ImageBitmap height\");if(s.height=o.height,void 0!==t.width&&t.width!==o.width)throw new Error(\"Image input config width doesn't match ImageBitmap width\");s.width=o.width}else s.height=o.height,s.width=o.width;r(h.bufferToTensor(e.data,s))}}));throw new Error(\"Input data provided is not supported - aborted tensor creation\")}{const r=\"RGBA\";let n,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,o=t.resizedWidth):(n=e.height,o=e.width),void 0!==t){if(s=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==r)throw new Error(\"Image input config format must be RGBA for ImageData\");s.bitmapFormat=\"RGBA\"}else s.bitmapFormat=\"RGBA\";if(s.height=n,s.width=o,void 0!==t){const t=document.createElement(\"canvas\");t.width=o,t.height=n;const r=t.getContext(\"2d\");if(null==r)throw new Error(\"Can not access image data\");r.putImageData(e,0,0),a=r.getImageData(0,0,o,n).data}else a=e.data}}if(void 0!==a)return h.bufferToTensor(a,s);throw new Error(\"Input data provided is not supported - aborted tensor creation\")}toImageData(e){var t,r;const n=document.createElement(\"canvas\").getContext(\"2d\");let o;if(null==n)throw new Error(\"Can not access image data\");{const i=this.dims[3],a=this.dims[2],s=this.dims[1],d=void 0!==e&&void 0!==e.format?e.format:\"RGB\",f=void 0!==e&&void 0!==(null===(t=e.norm)||void 0===t?void 0:t.mean)?e.norm.mean:255,h=void 0!==e&&void 0!==(null===(r=e.norm)||void 0===r?void 0:r.bias)?e.norm.bias:0,g=a*i;if(void 0!==e){if(void 0!==e.height&&e.height!==a)throw new Error(\"Image output config height doesn't match tensor height\");if(void 0!==e.width&&e.width!==i)throw new Error(\"Image output config width doesn't match tensor width\");if(void 0!==e.format&&4===s&&\"RGBA\"!==e.format||3===s&&\"RGB\"!==e.format&&\"BGR\"!==e.format)throw new Error(\"Tensor format doesn't match input tensor dims\")}const m=4;let c=0,l=1,w=2,u=3,p=0,y=g,b=2*g,v=-1;\"RGBA\"===d?(p=0,y=g,b=2*g,v=3*g):\"RGB\"===d?(p=0,y=g,b=2*g):\"RBG\"===d&&(p=0,b=g,y=2*g),o=n.createImageData(i,a);for(let e=0;e<a*i;c+=m,l+=m,w+=m,u+=m,e++)o.data[c]=(this.data[p++]-h)*f,o.data[l]=(this.data[y++]-h)*f,o.data[w]=(this.data[b++]-h)*f,o.data[u]=-1===v?255:(this.data[v++]-h)*f}return o}reshape(e){return new h(this.type,this.data,e)}}const g=h;class m{constructor(e){this.handler=e}async run(e,t,r){const n={};let o={};if(\"object\"!=typeof e||null===e||e instanceof g||Array.isArray(e))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let i=!0;if(\"object\"==typeof t){if(null===t)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(t instanceof g)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(t)){if(0===t.length)throw new TypeError(\"'fetches' cannot be an empty array.\");i=!1;for(const e of t){if(\"string\"!=typeof e)throw new TypeError(\"'fetches' must be a string array or an object.\");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if(\"object\"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError(\"'options' must be an object.\")}else{let e=!1;const a=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==a.indexOf(r)){const o=t[r];(null===o||o instanceof g)&&(e=!0,i=!1,n[r]=o)}if(e){if(\"object\"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError(\"'options' must be an object.\")}else o=t}}else if(void 0!==t)throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of this.outputNames)n[e]=null;const a=await this.handler.run(e,n,o),s={};for(const e in a)Object.hasOwnProperty.call(a,e)&&(s[e]=new g(a[e].type,a[e].data,a[e].dims));return s}static async create(e,t,o,i){let a,s={};if(\"string\"==typeof e){if(a=e,\"object\"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError(\"'options' must be an object.\")}else if(e instanceof Uint8Array){if(a=e,\"object\"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError(\"'options' must be an object.\")}else{if(!(e instanceof ArrayBuffer||\"undefined\"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");{const r=e;let n=0,d=e.byteLength;if(\"object\"==typeof t&&null!==t)s=t;else if(\"number\"==typeof t){if(n=t,!Number.isSafeInteger(n))throw new RangeError(\"'byteOffset' must be an integer.\");if(n<0||n>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(d=e.byteLength-n,\"number\"==typeof o){if(d=o,!Number.isSafeInteger(d))throw new RangeError(\"'byteLength' must be an integer.\");if(d<=0||n+d>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-n}].`);if(\"object\"==typeof i&&null!==i)s=i;else if(void 0!==i)throw new TypeError(\"'options' must be an object.\")}else if(void 0!==o)throw new TypeError(\"'byteLength' must be a number.\")}else if(void 0!==t)throw new TypeError(\"'options' must be an object.\");a=new Uint8Array(r,n,d)}}const d=(s.executionProviders||[]).map((e=>\"string\"==typeof e?e:e.name)),f=await(async e=>{const t=0===e.length?n:e,o=[];for(const e of t){const t=r[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(n){r||o.push({name:e,err:n}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${o.map((e=>`[${e.name}] ${e.err}`)).join(\", \")}`)})(d),h=await f.createSessionHandler(a,s);return new m(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const c=m;var l=exports;for(var w in t)l[w]=t[w];t.__esModule&&Object.defineProperty(l,\"__esModule\",{value:!0})})();\n//# sourceMappingURL=ort-common.node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3Qvb3J0LWNvbW1vbi5ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWEsT0FBTyxVQUFVLCtEQUErRCx1QkFBdUIsRUFBRSwwREFBMEQsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsR0FBRyxNQUFNLGNBQWMsb0VBQW9FLEVBQUUsVUFBVSxrQkFBa0Isd0hBQXdILGFBQWEsb0JBQW9CLHNCQUFzQixLQUFLLHVCQUF1Qiw2RUFBNkUsRUFBRSxtQkFBbUIsRUFBRSxHQUFHLFNBQVMscUJBQXFCLHNCQUFzQixZQUFZLFdBQVcsdURBQXVELFlBQVksYUFBYSxjQUFjLFlBQVksY0FBYyxpQ0FBaUMsZ0JBQWdCLGVBQWUsa0lBQWtJLEVBQUUsR0FBRyx5QkFBeUIsZUFBZSw4QkFBOEIsMmlCQUEyaUIsa0lBQWtJLFFBQVEsbUJBQW1CLFVBQVUsK0NBQStDLDJGQUEyRixJQUFJLEtBQUssaUJBQWlCLDhEQUE4RCxFQUFFLElBQUksZ0NBQWdDLEtBQUssOENBQThDLEdBQUcsZ0NBQWdDLEVBQUUsR0FBRyxLQUFLLDhCQUE4QiwyRkFBMkYsb0JBQW9CLCtCQUErQixLQUFLLDRFQUE0RSxFQUFFLElBQUksK0JBQStCLEtBQUssNkJBQTZCLHVFQUF1RSxjQUFjLElBQUksUUFBUSwyQkFBMkIsd0ZBQXdGLGFBQWEsUUFBUSxZQUFZLFdBQVcsS0FBSyxhQUFhLDRFQUE0RSxFQUFFLDZCQUE2QixFQUFFLEdBQUcsb0NBQW9DLEVBQUUseUNBQXlDLEVBQUUsR0FBRyxLQUFLLFNBQVMsS0FBSyxpREFBaUQsRUFBRSwrQkFBK0IsU0FBUyxLQUFLLGdEQUFnRCwyQkFBMkIsOERBQThELGlHQUFpRyxNQUFNLGlCQUFpQixZQUFZLFFBQVEsZ0ZBQWdGLDZMQUE2TCwyQ0FBMkMsd0dBQXdHLFlBQVksSUFBSSxrSEFBa0gseURBQXlELDRCQUE0Qix3UUFBd1EsV0FBVyxNQUFNLDhEQUE4RCx5REFBeUQsdUNBQXVDLG1IQUFtSCw4R0FBOEcsNElBQTRJLDZIQUE2SCxVQUFVLGdEQUFnRCw0RUFBNEUsS0FBSyxPQUFPLE1BQU0seUZBQXlGLHdHQUF3RywwREFBMEQsWUFBWSwyQkFBMkIscUVBQXFFLGlIQUFpSCx3SEFBd0gsVUFBVSwwQkFBMEIsNkJBQTZCLDZDQUE2QyxpQ0FBaUMsOERBQThELHFCQUFxQixrQkFBa0IsZ0RBQWdELHNFQUFzRSw2Q0FBNkMsZUFBZSx3SEFBd0gscUlBQXFJLGdCQUFnQix1Q0FBdUMsK0JBQStCLEdBQUcsbUZBQW1GLGVBQWUsUUFBUSx5SUFBeUksMkhBQTJILHNCQUFzQiwyQkFBMkIsb0NBQW9DLHlDQUF5QyxxQkFBcUIsMkJBQTJCLHdEQUF3RCxxREFBcUQsZUFBZSwyQ0FBMkMsa0ZBQWtGLGVBQWUsUUFBUSwwREFBMEQsTUFBTSx5REFBeUQsZ1JBQWdSLGVBQWUsNkdBQTZHLHlHQUF5RywySkFBMkosVUFBVSx1Q0FBdUMsK0dBQStHLFlBQVksTUFBTSwrSkFBK0osU0FBUyxXQUFXLHFDQUFxQyxVQUFVLFFBQVEsZUFBZSxlQUFlLGlCQUFpQixXQUFXLFNBQVMsdUxBQXVMLFNBQVMsdUJBQXVCLDJFQUEyRSxzRUFBc0UscUJBQXFCLDJFQUEyRSxLQUFLLGtCQUFrQiw0RkFBNEYsb0dBQW9HLEVBQUUsSUFBSSxVQUFVLG9DQUFvQyx1RUFBdUUsS0FBSyxTQUFTLHNDQUFzQyxzREFBc0QsYUFBYSwrQ0FBK0MsTUFBTSxvQ0FBb0MsdUVBQXVFLFVBQVUsa0dBQWtHLDBFQUEwRSxFQUFFLDJCQUEyQiwrQ0FBK0MsMkNBQTJDLDhGQUE4RixTQUFTLDZCQUE2QixXQUFXLHVCQUF1Qix3Q0FBd0MsdUVBQXVFLGlDQUFpQyx3Q0FBd0MsdUVBQXVFLEtBQUssa0xBQWtMLFVBQVUsdUJBQXVCLG9DQUFvQyw0QkFBNEIseUZBQXlGLGlGQUFpRixhQUFhLEtBQUssd0NBQXdDLHlGQUF5RixtRkFBbUYsZUFBZSxLQUFLLG9DQUFvQyx1RUFBdUUseUVBQXlFLHVFQUF1RSx5QkFBeUIsMkZBQTJGLDhCQUE4QixrQkFBa0IsYUFBYSxNQUFNLGtDQUFrQyxzQkFBc0Isd0JBQXdCLElBQUksMEZBQTBGLFNBQVMsV0FBVyxhQUFhLGVBQWUsUUFBUSx1QkFBdUIsb0RBQW9ELGNBQWMsT0FBTyxJQUFJLE1BQU0sZUFBZSxHQUFHLHlDQUF5QyxnQkFBZ0IsaUJBQWlCLDhCQUE4QixlQUFlLDRCQUE0QixpQkFBaUIsK0JBQStCLGtCQUFrQixpQ0FBaUMsVUFBVSxjQUFjLHlCQUF5QixvREFBb0QsU0FBUyxFQUFFO0FBQ2wvWCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9vcnQtY29tbW9uLm5vZGUuanM/YWYyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBDb21tb24gdjEuMTQuMFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOih0LHIpPT57Zm9yKHZhciBuIGluIHIpZS5vKHIsbikmJiFlLm8odCxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxnZXQ6cltuXX0pfSxvOihlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sdD17fTtlLnIodCksZS5kKHQse0luZmVyZW5jZVNlc3Npb246KCk9PmMsVGVuc29yOigpPT5nLGVudjooKT0+aSxyZWdpc3RlckJhY2tlbmQ6KCk9Pm99KTtjb25zdCByPXt9LG49W10sbz0oZSx0LG8pPT57aWYoIXR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuaW5pdHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdC5jcmVhdGVTZXNzaW9uSGFuZGxlcil0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKTt7Y29uc3QgaT1yW2VdO2lmKHZvaWQgMD09PWkpcltlXT17YmFja2VuZDp0LHByaW9yaXR5Om99O2Vsc2V7aWYoaS5wcmlvcml0eT5vKXJldHVybjtpZihpLnByaW9yaXR5PT09byYmaS5iYWNrZW5kIT09dCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtlfVwiIHVzaW5nIHByaW9yaXR5ICR7b31gKX1pZihvPj0wKXtjb25zdCB0PW4uaW5kZXhPZihlKTstMSE9PXQmJm4uc3BsaWNlKHQsMSk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0KyspaWYocltuW3RdXS5wcmlvcml0eTw9bylyZXR1cm4gdm9pZCBuLnNwbGljZSh0LDAsZSk7bi5wdXNoKGUpfX19LGk9bmV3IGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy53YXNtPXt9LHRoaXMud2ViZ2w9e30sdGhpcy5sb2dMZXZlbEludGVybmFsPVwid2FybmluZ1wifXNldCBsb2dMZXZlbChlKXtpZih2b2lkIDAhPT1lKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZXx8LTE9PT1bXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTt0aGlzLmxvZ0xldmVsSW50ZXJuYWw9ZX19Z2V0IGxvZ0xldmVsKCl7cmV0dXJuIHRoaXMubG9nTGV2ZWxJbnRlcm5hbH19LGE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJpZ0ludDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEJpZ0ludDY0QXJyYXkuZnJvbSxzPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBCaWdVaW50NjRBcnJheSYmXCJmdW5jdGlvblwiPT10eXBlb2YgQmlnVWludDY0QXJyYXkuZnJvbSxkPW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldXSksZj1uZXcgTWFwKFtbRmxvYXQzMkFycmF5LFwiZmxvYXQzMlwiXSxbVWludDhBcnJheSxcInVpbnQ4XCJdLFtJbnQ4QXJyYXksXCJpbnQ4XCJdLFtVaW50MTZBcnJheSxcInVpbnQxNlwiXSxbSW50MTZBcnJheSxcImludDE2XCJdLFtJbnQzMkFycmF5LFwiaW50MzJcIl0sW0Zsb2F0NjRBcnJheSxcImZsb2F0NjRcIl0sW1VpbnQzMkFycmF5LFwidWludDMyXCJdXSk7YSYmKGQuc2V0KFwiaW50NjRcIixCaWdJbnQ2NEFycmF5KSxmLnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHMmJihkLnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxmLnNldChCaWdVaW50NjRBcnJheSxcInVpbnQ2NFwiKSk7Y2xhc3MgaHtjb25zdHJ1Y3RvcihlLHQscil7bGV0IG4sbyxpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKWlmKG49ZSxpPXIsXCJzdHJpbmdcIj09PWUpe2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO289dH1lbHNle2NvbnN0IHI9ZC5nZXQoZSk7aWYodm9pZCAwPT09cil0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHtlfS5gKTtpZihBcnJheS5pc0FycmF5KHQpKW89ci5mcm9tKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgcikpdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke259IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7cn1gKTtvPXR9fWVsc2UgaWYoaT10LEFycmF5LmlzQXJyYXkoZSkpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2NvbnN0IHQ9dHlwZW9mIGVbMF07aWYoXCJzdHJpbmdcIj09PXQpbj1cInN0cmluZ1wiLG89ZTtlbHNle2lmKFwiYm9vbGVhblwiIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke3R9LmApO249XCJib29sXCIsbz1VaW50OEFycmF5LmZyb20oZSl9fWVsc2V7Y29uc3QgdD1mLmdldChlLmNvbnN0cnVjdG9yKTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2UuY29uc3RydWN0b3J9LmApO249dCxvPWV9aWYodm9pZCAwPT09aSlpPVtvLmxlbmd0aF07ZWxzZSBpZighQXJyYXkuaXNBcnJheShpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7Y29uc3QgYT0oZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IG49ZVtyXTtpZihcIm51bWJlclwiIT10eXBlb2Ygbnx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtyfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7bn1gKTtpZihuPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtyfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7bn1gKTt0Kj1ufXJldHVybiB0fSkoaSk7aWYoYSE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke2F9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke28ubGVuZ3RofSkuYCk7dGhpcy5kaW1zPWksdGhpcy50eXBlPW4sdGhpcy5kYXRhPW8sdGhpcy5zaXplPWF9c3RhdGljIGJ1ZmZlclRvVGVuc29yKGUsdCl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHZvaWQgMD09PXQuaGVpZ2h0fHx2b2lkIDA9PT10LndpZHRoKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkXCIpO2NvbnN0e2hlaWdodDpyLHdpZHRoOm59PXQsbz10Lm5vcm07bGV0IGksYTtpPXZvaWQgMD09PW98fHZvaWQgMD09PW8ubWVhbj8yNTU6by5tZWFuLGE9dm9pZCAwPT09b3x8dm9pZCAwPT09by5iaWFzPzA6by5iaWFzO2NvbnN0IHM9dm9pZCAwIT09dC5iaXRtYXBGb3JtYXQ/dC5iaXRtYXBGb3JtYXQ6XCJSR0JBXCIsZD12b2lkIDAhPT10LnRlbnNvckZvcm1hdCYmdm9pZCAwIT09dC50ZW5zb3JGb3JtYXQ/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixmPXIqbixnPVwiUkdCQVwiPT09ZD9uZXcgRmxvYXQzMkFycmF5KDQqZik6bmV3IEZsb2F0MzJBcnJheSgzKmYpO2xldCBtPTQsYz0wLGw9MSx3PTIsdT0zLHA9MCx5PWYsYj0yKmYsdj0tMTtcIlJHQlwiPT09cyYmKG09MyxjPTAsbD0xLHc9Mix1PS0xKSxcIlJHQkFcIj09PWQ/dj0zKmY6XCJSQkdcIj09PWQ/KHA9MCxiPWYseT0yKmYpOlwiQkdSXCI9PT1kJiYoYj0wLHk9ZixwPTIqZik7Zm9yKGxldCB0PTA7dDxmO3QrKyxjKz1tLHcrPW0sbCs9bSx1Kz1tKWdbcCsrXT0oZVtjXSthKS9pLGdbeSsrXT0oZVtsXSthKS9pLGdbYisrXT0oZVt3XSthKS9pLC0xIT09diYmLTEhPT11JiYoZ1t2KytdPShlW3VdK2EpL2kpO3JldHVybiBuZXcgaChcImZsb2F0MzJcIixnLFwiUkdCQVwiPT09ZD9bMSw0LHIsbl06WzEsMyxyLG5dKX1zdGF0aWMgYXN5bmMgZnJvbUltYWdlKGUsdCl7Y29uc3Qgcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTEltYWdlRWxlbWVudCYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgSW1hZ2VEYXRhJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEltYWdlQml0bWFwJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsaT1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3RyaW5nJiYoZSBpbnN0YW5jZW9mIFN0cmluZ3x8XCJzdHJpbmdcIj09dHlwZW9mIGUpO2xldCBhLHM9e307aWYocil7Y29uc3Qgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLG49ci5nZXRDb250ZXh0KFwiMmRcIik7aWYobnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3tsZXQgbz1lLm5hdHVyYWxIZWlnaHQsaT1lLm5hdHVyYWxXaWR0aDtpZih2b2lkIDAhPT10JiZ2b2lkIDAhPT10LnJlc2l6ZWRIZWlnaHQmJnZvaWQgMCE9PXQucmVzaXplZFdpZHRoJiYobz10LnJlc2l6ZWRIZWlnaHQsaT10LnJlc2l6ZWRXaWR0aCksdm9pZCAwIT09dCl7aWYocz10LHZvaWQgMCE9PXQudGVuc29yRm9ybWF0KXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2lmKHMudGVuc29yRm9ybWF0PVwiUkdCQVwiLHZvaWQgMCE9PXQuaGVpZ2h0JiZ0LmhlaWdodCE9PW8pdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2Vzbid0IG1hdGNoIEhUTUxJbWFnZUVsZW1lbnQgaGVpZ2h0XCIpO2lmKHMuaGVpZ2h0PW8sdm9pZCAwIT09dC53aWR0aCYmdC53aWR0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIHdpZHRoIGRvZXNuJ3QgbWF0Y2ggSFRNTEltYWdlRWxlbWVudCB3aWR0aFwiKTtzLndpZHRoPWl9ZWxzZSBzLnRlbnNvckZvcm1hdD1cIlJHQkFcIixzLmhlaWdodD1vLHMud2lkdGg9aTtyLndpZHRoPWksci5oZWlnaHQ9byxuLmRyYXdJbWFnZShlLDAsMCxpLG8pLGE9bi5nZXRJbWFnZURhdGEoMCwwLGksbykuZGF0YX19ZWxzZXtpZighbil7aWYobyl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2lmKHZvaWQgMCE9PXQuYml0bWFwRm9ybWF0KXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBkZWZpbmVkIGZvciBJbWFnZUJpdG1hcFwiKTtjb25zdCByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG51bGwhPXIpe2NvbnN0IG49ZS5oZWlnaHQsbz1lLndpZHRoO2lmKHIuZHJhd0ltYWdlKGUsMCwwLG8sbiksYT1yLmdldEltYWdlRGF0YSgwLDAsbyxuKS5kYXRhLHZvaWQgMCE9PXQpe2lmKHZvaWQgMCE9PXQuaGVpZ2h0JiZ0LmhlaWdodCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2Vzbid0IG1hdGNoIEltYWdlQml0bWFwIGhlaWdodFwiKTtpZihzLmhlaWdodD1uLHZvaWQgMCE9PXQud2lkdGgmJnQud2lkdGghPT1vKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIEltYWdlQml0bWFwIHdpZHRoXCIpO3Mud2lkdGg9b31lbHNlIHMuaGVpZ2h0PW4scy53aWR0aD1vO3JldHVybiBoLmJ1ZmZlclRvVGVuc29yKGEscyl9dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1pZihpKXJldHVybiBuZXcgUHJvbWlzZSgoKHIsbik9Pntjb25zdCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksaT1vLmdldENvbnRleHQoXCIyZFwiKTtpZighZXx8IWkpcmV0dXJuIG4oKTtjb25zdCBhPW5ldyBJbWFnZTthLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIsYS5zcmM9ZSxhLm9ubG9hZD0oKT0+e28ud2lkdGg9YS53aWR0aCxvLmhlaWdodD1hLmhlaWdodCxpLmRyYXdJbWFnZShhLDAsMCxvLndpZHRoLG8uaGVpZ2h0KTtjb25zdCBlPWkuZ2V0SW1hZ2VEYXRhKDAsMCxvLndpZHRoLG8uaGVpZ2h0KTtpZih2b2lkIDAhPT10KXtpZih2b2lkIDAhPT10LmhlaWdodCYmdC5oZWlnaHQhPT1vLmhlaWdodCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgaGVpZ2h0IGRvZXNuJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgaGVpZ2h0XCIpO2lmKHMuaGVpZ2h0PW8uaGVpZ2h0LHZvaWQgMCE9PXQud2lkdGgmJnQud2lkdGghPT1vLndpZHRoKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIEltYWdlQml0bWFwIHdpZHRoXCIpO3Mud2lkdGg9by53aWR0aH1lbHNlIHMuaGVpZ2h0PW8uaGVpZ2h0LHMud2lkdGg9by53aWR0aDtyKGguYnVmZmVyVG9UZW5zb3IoZS5kYXRhLHMpKX19KSk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9e2NvbnN0IHI9XCJSR0JBXCI7bGV0IG4sbztpZih2b2lkIDAhPT10JiZ2b2lkIDAhPT10LnJlc2l6ZWRXaWR0aCYmdm9pZCAwIT09dC5yZXNpemVkSGVpZ2h0PyhuPXQucmVzaXplZEhlaWdodCxvPXQucmVzaXplZFdpZHRoKToobj1lLmhlaWdodCxvPWUud2lkdGgpLHZvaWQgMCE9PXQpe2lmKHM9dCx2b2lkIDAhPT10LmJpdG1hcEZvcm1hdCYmdC5iaXRtYXBGb3JtYXQhPT1yKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBJbWFnZURhdGFcIik7cy5iaXRtYXBGb3JtYXQ9XCJSR0JBXCJ9ZWxzZSBzLmJpdG1hcEZvcm1hdD1cIlJHQkFcIjtpZihzLmhlaWdodD1uLHMud2lkdGg9byx2b2lkIDAhPT10KXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7dC53aWR0aD1vLHQuaGVpZ2h0PW47Y29uc3Qgcj10LmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIik7ci5wdXRJbWFnZURhdGEoZSwwLDApLGE9ci5nZXRJbWFnZURhdGEoMCwwLG8sbikuZGF0YX1lbHNlIGE9ZS5kYXRhfX1pZih2b2lkIDAhPT1hKXJldHVybiBoLmJ1ZmZlclRvVGVuc29yKGEscyk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9dG9JbWFnZURhdGEoZSl7dmFyIHQscjtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO2xldCBvO2lmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTt7Y29uc3QgaT10aGlzLmRpbXNbM10sYT10aGlzLmRpbXNbMl0scz10aGlzLmRpbXNbMV0sZD12b2lkIDAhPT1lJiZ2b2lkIDAhPT1lLmZvcm1hdD9lLmZvcm1hdDpcIlJHQlwiLGY9dm9pZCAwIT09ZSYmdm9pZCAwIT09KG51bGw9PT0odD1lLm5vcm0pfHx2b2lkIDA9PT10P3ZvaWQgMDp0Lm1lYW4pP2Uubm9ybS5tZWFuOjI1NSxoPXZvaWQgMCE9PWUmJnZvaWQgMCE9PShudWxsPT09KHI9ZS5ub3JtKXx8dm9pZCAwPT09cj92b2lkIDA6ci5iaWFzKT9lLm5vcm0uYmlhczowLGc9YSppO2lmKHZvaWQgMCE9PWUpe2lmKHZvaWQgMCE9PWUuaGVpZ2h0JiZlLmhlaWdodCE9PWEpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2Ugb3V0cHV0IGNvbmZpZyBoZWlnaHQgZG9lc24ndCBtYXRjaCB0ZW5zb3IgaGVpZ2h0XCIpO2lmKHZvaWQgMCE9PWUud2lkdGgmJmUud2lkdGghPT1pKXRocm93IG5ldyBFcnJvcihcIkltYWdlIG91dHB1dCBjb25maWcgd2lkdGggZG9lc24ndCBtYXRjaCB0ZW5zb3Igd2lkdGhcIik7aWYodm9pZCAwIT09ZS5mb3JtYXQmJjQ9PT1zJiZcIlJHQkFcIiE9PWUuZm9ybWF0fHwzPT09cyYmXCJSR0JcIiE9PWUuZm9ybWF0JiZcIkJHUlwiIT09ZS5mb3JtYXQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpfWNvbnN0IG09NDtsZXQgYz0wLGw9MSx3PTIsdT0zLHA9MCx5PWcsYj0yKmcsdj0tMTtcIlJHQkFcIj09PWQ/KHA9MCx5PWcsYj0yKmcsdj0zKmcpOlwiUkdCXCI9PT1kPyhwPTAseT1nLGI9MipnKTpcIlJCR1wiPT09ZCYmKHA9MCxiPWcseT0yKmcpLG89bi5jcmVhdGVJbWFnZURhdGEoaSxhKTtmb3IobGV0IGU9MDtlPGEqaTtjKz1tLGwrPW0sdys9bSx1Kz1tLGUrKylvLmRhdGFbY109KHRoaXMuZGF0YVtwKytdLWgpKmYsby5kYXRhW2xdPSh0aGlzLmRhdGFbeSsrXS1oKSpmLG8uZGF0YVt3XT0odGhpcy5kYXRhW2IrK10taCkqZixvLmRhdGFbdV09LTE9PT12PzI1NToodGhpcy5kYXRhW3YrK10taCkqZn1yZXR1cm4gb31yZXNoYXBlKGUpe3JldHVybiBuZXcgaCh0aGlzLnR5cGUsdGhpcy5kYXRhLGUpfX1jb25zdCBnPWg7Y2xhc3MgbXtjb25zdHJ1Y3RvcihlKXt0aGlzLmhhbmRsZXI9ZX1hc3luYyBydW4oZSx0LHIpe2NvbnN0IG49e307bGV0IG89e307aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lfHxlIGluc3RhbmNlb2YgZ3x8QXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCBpPSEwO2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKHQgaW5zdGFuY2VvZiBnKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkodCkpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7aT0hMTtmb3IoY29uc3QgZSBvZiB0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZigtMT09PXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihlKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7ZX0uYCk7bltlXT1udWxsfWlmKFwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cilvPXI7ZWxzZSBpZih2b2lkIDAhPT1yKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IGU9ITE7Y29uc3QgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KTtmb3IoY29uc3QgciBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKC0xIT09YS5pbmRleE9mKHIpKXtjb25zdCBvPXRbcl07KG51bGw9PT1vfHxvIGluc3RhbmNlb2YgZykmJihlPSEwLGk9ITEsbltyXT1vKX1pZihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmbnVsbCE9PXIpbz1yO2Vsc2UgaWYodm9pZCAwIT09cil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIG89dH19ZWxzZSBpZih2b2lkIDAhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2Zvcihjb25zdCB0IG9mIHRoaXMuaW5wdXROYW1lcylpZih2b2lkIDA9PT1lW3RdKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7dH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZihpKWZvcihjb25zdCBlIG9mIHRoaXMub3V0cHV0TmFtZXMpbltlXT1udWxsO2NvbnN0IGE9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihlLG4sbykscz17fTtmb3IoY29uc3QgZSBpbiBhKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsZSkmJihzW2VdPW5ldyBnKGFbZV0udHlwZSxhW2VdLmRhdGEsYVtlXS5kaW1zKSk7cmV0dXJuIHN9c3RhdGljIGFzeW5jIGNyZWF0ZShlLHQsbyxpKXtsZXQgYSxzPXt9O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihhPWUsXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10KXM9dDtlbHNlIGlmKHZvaWQgMCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZihlIGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoYT1lLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dClzPXQ7ZWxzZSBpZih2b2lkIDAhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7aWYoIShlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO3tjb25zdCByPWU7bGV0IG49MCxkPWUuYnl0ZUxlbmd0aDtpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpcz10O2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2lmKG49dCwhTnVtYmVyLmlzU2FmZUludGVnZXIobikpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihuPDB8fG4+PXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtyLmJ5dGVMZW5ndGh9KS5gKTtpZihkPWUuYnl0ZUxlbmd0aC1uLFwibnVtYmVyXCI9PXR5cGVvZiBvKXtpZihkPW8sIU51bWJlci5pc1NhZmVJbnRlZ2VyKGQpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoZDw9MHx8bitkPnIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtyLmJ5dGVMZW5ndGgtbn1dLmApO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZudWxsIT09aSlzPWk7ZWxzZSBpZih2b2lkIDAhPT1pKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodm9pZCAwIT09byl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYSBudW1iZXIuXCIpfWVsc2UgaWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTthPW5ldyBVaW50OEFycmF5KHIsbixkKX19Y29uc3QgZD0ocy5leGVjdXRpb25Qcm92aWRlcnN8fFtdKS5tYXAoKGU9Plwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS5uYW1lKSksZj1hd2FpdChhc3luYyBlPT57Y29uc3QgdD0wPT09ZS5sZW5ndGg/bjplLG89W107Zm9yKGNvbnN0IGUgb2YgdCl7Y29uc3QgdD1yW2VdO2lmKHQpe2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpY29udGludWU7Y29uc3Qgcj0hIXQuaW5pdFByb21pc2U7dHJ5e3JldHVybiByfHwodC5pbml0UHJvbWlzZT10LmJhY2tlbmQuaW5pdCgpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKG4pe3J8fG8ucHVzaCh7bmFtZTplLGVycjpufSksdC5hYm9ydGVkPSEwfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX10aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7by5tYXAoKGU9PmBbJHtlLm5hbWV9XSAke2UuZXJyfWApKS5qb2luKFwiLCBcIil9YCl9KShkKSxoPWF3YWl0IGYuY3JlYXRlU2Vzc2lvbkhhbmRsZXIoYSxzKTtyZXR1cm4gbmV3IG0oaCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc319Y29uc3QgYz1tO3ZhciBsPWV4cG9ydHM7Zm9yKHZhciB3IGluIHQpbFt3XT10W3ddO3QuX19lc01vZHVsZSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0LWNvbW1vbi5ub2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/ort-common.node.js\n");

/***/ })

};
;